"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("main-app",{

/***/ "(app-pages-browser)/./node_modules/next/dist/client/components/http-access-fallback/error-boundary.js":
/*!*****************************************************************************************!*\
  !*** ./node_modules/next/dist/client/components/http-access-fallback/error-boundary.js ***!
  \*****************************************************************************************/
/***/ ((module, exports, __webpack_require__) => {

eval(__webpack_require__.ts("/* __next_internal_client_entry_do_not_use__  cjs */ \nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nObject.defineProperty(exports, \"HTTPAccessFallbackBoundary\", ({\n    enumerable: true,\n    get: function() {\n        return HTTPAccessFallbackBoundary;\n    }\n}));\nconst _interop_require_wildcard = __webpack_require__(/*! @swc/helpers/_/_interop_require_wildcard */ \"(app-pages-browser)/./node_modules/@swc/helpers/esm/_interop_require_wildcard.js\");\nconst _jsxruntime = __webpack_require__(/*! react/jsx-runtime */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/jsx-runtime.js\");\nconst _react = /*#__PURE__*/ _interop_require_wildcard._(__webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\"));\nconst _navigationuntracked = __webpack_require__(/*! ../navigation-untracked */ \"(app-pages-browser)/./node_modules/next/dist/client/components/navigation-untracked.js\");\nconst _httpaccessfallback = __webpack_require__(/*! ./http-access-fallback */ \"(app-pages-browser)/./node_modules/next/dist/client/components/http-access-fallback/http-access-fallback.js\");\nconst _warnonce = __webpack_require__(/*! ../../../shared/lib/utils/warn-once */ \"(app-pages-browser)/./node_modules/next/dist/shared/lib/utils/warn-once.js\");\nconst _approutercontextsharedruntime = __webpack_require__(/*! ../../../shared/lib/app-router-context.shared-runtime */ \"(app-pages-browser)/./node_modules/next/dist/shared/lib/app-router-context.shared-runtime.js\");\nclass HTTPAccessFallbackErrorBoundary extends _react.default.Component {\n    componentDidCatch() {\n        if ( true && this.props.missingSlots && this.props.missingSlots.size > 0 && // A missing children slot is the typical not-found case, so no need to warn\n        !this.props.missingSlots.has('children')) {\n            let warningMessage = 'No default component was found for a parallel route rendered on this page. Falling back to nearest NotFound boundary.\\n' + 'Learn more: https://nextjs.org/docs/app/building-your-application/routing/parallel-routes#defaultjs\\n\\n';\n            const formattedSlots = Array.from(this.props.missingSlots).sort((a, b)=>a.localeCompare(b)).map((slot)=>\"@\" + slot).join(', ');\n            warningMessage += 'Missing slots: ' + formattedSlots;\n            (0, _warnonce.warnOnce)(warningMessage);\n        }\n    }\n    static getDerivedStateFromError(error) {\n        if ((0, _httpaccessfallback.isHTTPAccessFallbackError)(error)) {\n            const httpStatus = (0, _httpaccessfallback.getAccessFallbackHTTPStatus)(error);\n            return {\n                triggeredStatus: httpStatus\n            };\n        }\n        // Re-throw if error is not for 404\n        throw error;\n    }\n    static getDerivedStateFromProps(props, state) {\n        /**\n     * Handles reset of the error boundary when a navigation happens.\n     * Ensures the error boundary does not stay enabled when navigating to a new page.\n     * Approach of setState in render is safe as it checks the previous pathname and then overrides\n     * it as outlined in https://react.dev/reference/react/useState#storing-information-from-previous-renders\n     */ if (props.pathname !== state.previousPathname && state.triggeredStatus) {\n            return {\n                triggeredStatus: undefined,\n                previousPathname: props.pathname\n            };\n        }\n        return {\n            triggeredStatus: state.triggeredStatus,\n            previousPathname: props.pathname\n        };\n    }\n    render() {\n        const { notFound, forbidden, unauthorized, children } = this.props;\n        const { triggeredStatus } = this.state;\n        const errorComponents = {\n            [_httpaccessfallback.HTTPAccessErrorStatus.NOT_FOUND]: notFound,\n            [_httpaccessfallback.HTTPAccessErrorStatus.FORBIDDEN]: forbidden,\n            [_httpaccessfallback.HTTPAccessErrorStatus.UNAUTHORIZED]: unauthorized\n        };\n        if (triggeredStatus) {\n            const isNotFound = triggeredStatus === _httpaccessfallback.HTTPAccessErrorStatus.NOT_FOUND && notFound;\n            const isForbidden = triggeredStatus === _httpaccessfallback.HTTPAccessErrorStatus.FORBIDDEN && forbidden;\n            const isUnauthorized = triggeredStatus === _httpaccessfallback.HTTPAccessErrorStatus.UNAUTHORIZED && unauthorized;\n            // If there's no matched boundary in this layer, keep throwing the error by rendering the children\n            if (!(isNotFound || isForbidden || isUnauthorized)) {\n                return children;\n            }\n            return /*#__PURE__*/ (0, _jsxruntime.jsxs)(_jsxruntime.Fragment, {\n                children: [\n                    /*#__PURE__*/ (0, _jsxruntime.jsx)(\"meta\", {\n                        name: \"robots\",\n                        content: \"noindex\"\n                    }),\n                     true && /*#__PURE__*/ (0, _jsxruntime.jsx)(\"meta\", {\n                        name: \"boundary-next-error\",\n                        content: (0, _httpaccessfallback.getAccessFallbackErrorTypeByStatus)(triggeredStatus)\n                    }),\n                    errorComponents[triggeredStatus]\n                ]\n            });\n        }\n        return children;\n    }\n    constructor(props){\n        super(props);\n        this.state = {\n            triggeredStatus: undefined,\n            previousPathname: props.pathname\n        };\n    }\n}\nfunction HTTPAccessFallbackBoundary(param) {\n    let { notFound, forbidden, unauthorized, children } = param;\n    // When we're rendering the missing params shell, this will return null. This\n    // is because we won't be rendering any not found boundaries or error\n    // boundaries for the missing params shell. When this runs on the client\n    // (where these error can occur), we will get the correct pathname.\n    const pathname = (0, _navigationuntracked.useUntrackedPathname)();\n    const missingSlots = (0, _react.useContext)(_approutercontextsharedruntime.MissingSlotContext);\n    const hasErrorFallback = !!(notFound || forbidden || unauthorized);\n    if (hasErrorFallback) {\n        return /*#__PURE__*/ (0, _jsxruntime.jsx)(HTTPAccessFallbackErrorBoundary, {\n            pathname: pathname,\n            notFound: notFound,\n            forbidden: forbidden,\n            unauthorized: unauthorized,\n            missingSlots: missingSlots,\n            children: children\n        });\n    }\n    return /*#__PURE__*/ (0, _jsxruntime.jsx)(_jsxruntime.Fragment, {\n        children: children\n    });\n}\n_c = HTTPAccessFallbackBoundary;\nif ((typeof exports.default === 'function' || typeof exports.default === 'object' && exports.default !== null) && typeof exports.default.__esModule === 'undefined') {\n    Object.defineProperty(exports.default, '__esModule', {\n        value: true\n    });\n    Object.assign(exports.default, exports);\n    module.exports = exports.default;\n} //# sourceMappingURL=error-boundary.js.map\nvar _c;\n$RefreshReg$(_c, \"HTTPAccessFallbackBoundary\");\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvY2xpZW50L2NvbXBvbmVudHMvaHR0cC1hY2Nlc3MtZmFsbGJhY2svZXJyb3ItYm91bmRhcnkuanMiLCJtYXBwaW5ncyI6Ijs7Ozs4REF1SmdCQTs7O2VBQUFBOzs7Ozs2RUExSWtCO2lEQUNHO2dEQU05QjtzQ0FDa0I7MkRBQ1U7QUFxQm5DLE1BQU1DLHdDQUF3Q0MsT0FBQUEsT0FBSyxDQUFDQyxTQUFTO0lBWTNEQyxvQkFBMEI7UUFDeEIsSUFDRUMsS0FBb0IsSUFDcEIsSUFBSSxDQUFDRyxLQUFLLENBQUNDLFlBQVksSUFDdkIsSUFBSSxDQUFDRCxLQUFLLENBQUNDLFlBQVksQ0FBQ0MsSUFBSSxHQUFHLEtBQy9CLDRFQUE0RTtRQUM1RSxDQUFDLElBQUksQ0FBQ0YsS0FBSyxDQUFDQyxZQUFZLENBQUNFLEdBQUcsQ0FBQyxhQUM3QjtZQUNBLElBQUlDLGlCQUNGLDRIQUNBO1lBRUYsTUFBTUMsaUJBQWlCQyxNQUFNQyxJQUFJLENBQUMsSUFBSSxDQUFDUCxLQUFLLENBQUNDLFlBQVksRUFDdERPLElBQUksQ0FBQyxDQUFDQyxHQUFHQyxJQUFNRCxFQUFFRSxhQUFhLENBQUNELElBQy9CRSxHQUFHLENBQUMsQ0FBQ0MsT0FBVSxNQUFHQSxNQUNsQkMsSUFBSSxDQUFDO1lBRVJWLGtCQUFrQixvQkFBb0JDO1lBRXRDVSxDQUFBQSxHQUFBQSxVQUFBQSxRQUFBQSxFQUFTWDtRQUNYO0lBQ0Y7SUFFQSxPQUFPWSx5QkFBeUJDLEtBQVUsRUFBRTtRQUMxQyxJQUFJQyxDQUFBQSxHQUFBQSxvQkFBQUEseUJBQUFBLEVBQTBCRCxRQUFRO1lBQ3BDLE1BQU1FLGFBQWFDLENBQUFBLEdBQUFBLG9CQUFBQSwyQkFBQUEsRUFBNEJIO1lBQy9DLE9BQU87Z0JBQ0xJLGlCQUFpQkY7WUFDbkI7UUFDRjtRQUNBLG1DQUFtQztRQUNuQyxNQUFNRjtJQUNSO0lBRUEsT0FBT0sseUJBQ0x0QixLQUEyQyxFQUMzQ3VCLEtBQThCLEVBQ0U7UUFDaEM7Ozs7O0tBS0MsR0FDRCxJQUFJdkIsTUFBTXdCLFFBQVEsS0FBS0QsTUFBTUUsZ0JBQWdCLElBQUlGLE1BQU1GLGVBQWUsRUFBRTtZQUN0RSxPQUFPO2dCQUNMQSxpQkFBaUJLO2dCQUNqQkQsa0JBQWtCekIsTUFBTXdCLFFBQVE7WUFDbEM7UUFDRjtRQUNBLE9BQU87WUFDTEgsaUJBQWlCRSxNQUFNRixlQUFlO1lBQ3RDSSxrQkFBa0J6QixNQUFNd0IsUUFBUTtRQUNsQztJQUNGO0lBRUFHLFNBQVM7UUFDUCxNQUFNLEVBQUVDLFFBQVEsRUFBRUMsU0FBUyxFQUFFQyxZQUFZLEVBQUVDLFFBQVEsRUFBRSxHQUFHLElBQUksQ0FBQy9CLEtBQUs7UUFDbEUsTUFBTSxFQUFFcUIsZUFBZSxFQUFFLEdBQUcsSUFBSSxDQUFDRSxLQUFLO1FBQ3RDLE1BQU1TLGtCQUFrQjtZQUN0QixDQUFDQyxvQkFBQUEscUJBQXFCLENBQUNDLFNBQVMsQ0FBQyxFQUFFTjtZQUNuQyxDQUFDSyxvQkFBQUEscUJBQXFCLENBQUNFLFNBQVMsQ0FBQyxFQUFFTjtZQUNuQyxDQUFDSSxvQkFBQUEscUJBQXFCLENBQUNHLFlBQVksQ0FBQyxFQUFFTjtRQUN4QztRQUVBLElBQUlULGlCQUFpQjtZQUNuQixNQUFNZ0IsYUFDSmhCLG9CQUFvQlksb0JBQUFBLHFCQUFxQixDQUFDQyxTQUFTLElBQUlOO1lBQ3pELE1BQU1VLGNBQ0pqQixvQkFBb0JZLG9CQUFBQSxxQkFBcUIsQ0FBQ0UsU0FBUyxJQUFJTjtZQUN6RCxNQUFNVSxpQkFDSmxCLG9CQUFvQlksb0JBQUFBLHFCQUFxQixDQUFDRyxZQUFZLElBQUlOO1lBRTVELGtHQUFrRztZQUNsRyxJQUFJLENBQUVPLENBQUFBLGNBQWNDLGVBQWVDLGNBQUFBLENBQWEsRUFBSTtnQkFDbEQsT0FBT1I7WUFDVDtZQUVBLHFCQUNFOztrQ0FDRSxxQkFBQ1MsUUFBQUE7d0JBQUtDLE1BQUs7d0JBQVNDLFNBQVE7O29CQWdCdEJsRCxLQWZpQyxJQUFiLGNBQ3hCLHFCQUFDZ0QsUUFBQUE7d0JBQ0NDLE1BQUs7d0JBQ0xDLFNBQVNDLENBQUFBLEdBQUFBLG9CQUFBQSxrQ0FBQUEsRUFBbUN0Qjs7b0JBRy9DVyxlQUFlLENBQUNYLGdCQUFnQjs7O1FBR3ZDO1FBRUEsT0FBT1U7SUFDVDtJQXJHQWEsWUFBWTVDLEtBQTJDLENBQUU7UUFDdkQsS0FBSyxDQUFDQTtRQUNOLElBQUksQ0FBQ3VCLEtBQUssR0FBRztZQUNYRixpQkFBaUJLO1lBQ2pCRCxrQkFBa0J6QixNQUFNd0IsUUFBUTtRQUNsQztJQUNGO0FBZ0dGO0FBRU8sb0NBQW9DLEtBS1Q7SUFMUyxNQUN6Q0ksUUFBUSxFQUNSQyxTQUFTLEVBQ1RDLFlBQVksRUFDWkMsUUFBUSxFQUN3QixHQUxTO0lBTXpDLDZFQUE2RTtJQUM3RSxxRUFBcUU7SUFDckUsd0VBQXdFO0lBQ3hFLG1FQUFtRTtJQUNuRSxNQUFNUCxXQUFXcUIsQ0FBQUEsR0FBQUEscUJBQUFBLG9CQUFBQTtJQUNqQixNQUFNNUMsZUFBZTZDLENBQUFBLEdBQUFBLE9BQUFBLFVBQUFBLEVBQVdDLCtCQUFBQSxrQkFBa0I7SUFDbEQsTUFBTUMsbUJBQW1CLENBQUMsQ0FBRXBCLENBQUFBLFlBQVlDLGFBQWFDLFlBQUFBLENBQVc7SUFFaEUsSUFBSWtCLGtCQUFrQjtRQUNwQixPQUNFLFdBREYsR0FDRSxxQkFBQ3ZELGlDQUFBQTtZQUNDK0IsVUFBVUE7WUFDVkksVUFBVUE7WUFDVkMsV0FBV0E7WUFDWEMsY0FBY0E7WUFDZDdCLGNBQWNBO3NCQUViOEI7O0lBR1A7SUFFQSxxQkFBTztrQkFBR0E7O0FBQ1o7S0E3QmdCdkMiLCJzb3VyY2VzIjpbIi9zcmMvY2xpZW50L2NvbXBvbmVudHMvaHR0cC1hY2Nlc3MtZmFsbGJhY2svZXJyb3ItYm91bmRhcnkudHN4Il0sInNvdXJjZXNDb250ZW50IjpbIid1c2UgY2xpZW50J1xuXG4vKipcbiAqIEhUVFBBY2Nlc3NGYWxsYmFja0JvdW5kYXJ5IGlzIGEgYm91bmRhcnkgdGhhdCBjYXRjaGVzIGVycm9ycyBhbmQgcmVuZGVycyBhXG4gKiBmYWxsYmFjayBjb21wb25lbnQgZm9yIEhUVFAgZXJyb3JzLlxuICpcbiAqIEl0IHJlY2VpdmVzIHRoZSBzdGF0dXMgY29kZSwgYW5kIGRldGVybWluZSBpZiBpdCBzaG91bGQgcmVuZGVyIGZhbGxiYWNrcyBmb3IgZmV3IEhUVFAgNHh4IGVycm9ycy5cbiAqXG4gKiBlLmcuIDQwNFxuICogNDA0IHJlcHJlc2VudHMgbm90IGZvdW5kLCBhbmQgdGhlIGZhbGxiYWNrIGNvbXBvbmVudCBwYWlyIGNvbnRhaW5zIHRoZSBjb21wb25lbnQgYW5kIGl0cyBzdHlsZXMuXG4gKlxuICovXG5cbmltcG9ydCBSZWFjdCwgeyB1c2VDb250ZXh0IH0gZnJvbSAncmVhY3QnXG5pbXBvcnQgeyB1c2VVbnRyYWNrZWRQYXRobmFtZSB9IGZyb20gJy4uL25hdmlnYXRpb24tdW50cmFja2VkJ1xuaW1wb3J0IHtcbiAgSFRUUEFjY2Vzc0Vycm9yU3RhdHVzLFxuICBnZXRBY2Nlc3NGYWxsYmFja0hUVFBTdGF0dXMsXG4gIGdldEFjY2Vzc0ZhbGxiYWNrRXJyb3JUeXBlQnlTdGF0dXMsXG4gIGlzSFRUUEFjY2Vzc0ZhbGxiYWNrRXJyb3IsXG59IGZyb20gJy4vaHR0cC1hY2Nlc3MtZmFsbGJhY2snXG5pbXBvcnQgeyB3YXJuT25jZSB9IGZyb20gJy4uLy4uLy4uL3NoYXJlZC9saWIvdXRpbHMvd2Fybi1vbmNlJ1xuaW1wb3J0IHsgTWlzc2luZ1Nsb3RDb250ZXh0IH0gZnJvbSAnLi4vLi4vLi4vc2hhcmVkL2xpYi9hcHAtcm91dGVyLWNvbnRleHQuc2hhcmVkLXJ1bnRpbWUnXG5cbmludGVyZmFjZSBIVFRQQWNjZXNzRmFsbGJhY2tCb3VuZGFyeVByb3BzIHtcbiAgbm90Rm91bmQ/OiBSZWFjdC5SZWFjdE5vZGVcbiAgZm9yYmlkZGVuPzogUmVhY3QuUmVhY3ROb2RlXG4gIHVuYXV0aG9yaXplZD86IFJlYWN0LlJlYWN0Tm9kZVxuICBjaGlsZHJlbjogUmVhY3QuUmVhY3ROb2RlXG4gIG1pc3NpbmdTbG90cz86IFNldDxzdHJpbmc+XG59XG5cbmludGVyZmFjZSBIVFRQQWNjZXNzRmFsbGJhY2tFcnJvckJvdW5kYXJ5UHJvcHNcbiAgZXh0ZW5kcyBIVFRQQWNjZXNzRmFsbGJhY2tCb3VuZGFyeVByb3BzIHtcbiAgcGF0aG5hbWU6IHN0cmluZyB8IG51bGxcbiAgbWlzc2luZ1Nsb3RzPzogU2V0PHN0cmluZz5cbn1cblxuaW50ZXJmYWNlIEhUVFBBY2Nlc3NCb3VuZGFyeVN0YXRlIHtcbiAgdHJpZ2dlcmVkU3RhdHVzOiBudW1iZXIgfCB1bmRlZmluZWRcbiAgcHJldmlvdXNQYXRobmFtZTogc3RyaW5nIHwgbnVsbFxufVxuXG5jbGFzcyBIVFRQQWNjZXNzRmFsbGJhY2tFcnJvckJvdW5kYXJ5IGV4dGVuZHMgUmVhY3QuQ29tcG9uZW50PFxuICBIVFRQQWNjZXNzRmFsbGJhY2tFcnJvckJvdW5kYXJ5UHJvcHMsXG4gIEhUVFBBY2Nlc3NCb3VuZGFyeVN0YXRlXG4+IHtcbiAgY29uc3RydWN0b3IocHJvcHM6IEhUVFBBY2Nlc3NGYWxsYmFja0Vycm9yQm91bmRhcnlQcm9wcykge1xuICAgIHN1cGVyKHByb3BzKVxuICAgIHRoaXMuc3RhdGUgPSB7XG4gICAgICB0cmlnZ2VyZWRTdGF0dXM6IHVuZGVmaW5lZCxcbiAgICAgIHByZXZpb3VzUGF0aG5hbWU6IHByb3BzLnBhdGhuYW1lLFxuICAgIH1cbiAgfVxuXG4gIGNvbXBvbmVudERpZENhdGNoKCk6IHZvaWQge1xuICAgIGlmIChcbiAgICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSAnZGV2ZWxvcG1lbnQnICYmXG4gICAgICB0aGlzLnByb3BzLm1pc3NpbmdTbG90cyAmJlxuICAgICAgdGhpcy5wcm9wcy5taXNzaW5nU2xvdHMuc2l6ZSA+IDAgJiZcbiAgICAgIC8vIEEgbWlzc2luZyBjaGlsZHJlbiBzbG90IGlzIHRoZSB0eXBpY2FsIG5vdC1mb3VuZCBjYXNlLCBzbyBubyBuZWVkIHRvIHdhcm5cbiAgICAgICF0aGlzLnByb3BzLm1pc3NpbmdTbG90cy5oYXMoJ2NoaWxkcmVuJylcbiAgICApIHtcbiAgICAgIGxldCB3YXJuaW5nTWVzc2FnZSA9XG4gICAgICAgICdObyBkZWZhdWx0IGNvbXBvbmVudCB3YXMgZm91bmQgZm9yIGEgcGFyYWxsZWwgcm91dGUgcmVuZGVyZWQgb24gdGhpcyBwYWdlLiBGYWxsaW5nIGJhY2sgdG8gbmVhcmVzdCBOb3RGb3VuZCBib3VuZGFyeS5cXG4nICtcbiAgICAgICAgJ0xlYXJuIG1vcmU6IGh0dHBzOi8vbmV4dGpzLm9yZy9kb2NzL2FwcC9idWlsZGluZy15b3VyLWFwcGxpY2F0aW9uL3JvdXRpbmcvcGFyYWxsZWwtcm91dGVzI2RlZmF1bHRqc1xcblxcbidcblxuICAgICAgY29uc3QgZm9ybWF0dGVkU2xvdHMgPSBBcnJheS5mcm9tKHRoaXMucHJvcHMubWlzc2luZ1Nsb3RzKVxuICAgICAgICAuc29ydCgoYSwgYikgPT4gYS5sb2NhbGVDb21wYXJlKGIpKVxuICAgICAgICAubWFwKChzbG90KSA9PiBgQCR7c2xvdH1gKVxuICAgICAgICAuam9pbignLCAnKVxuXG4gICAgICB3YXJuaW5nTWVzc2FnZSArPSAnTWlzc2luZyBzbG90czogJyArIGZvcm1hdHRlZFNsb3RzXG5cbiAgICAgIHdhcm5PbmNlKHdhcm5pbmdNZXNzYWdlKVxuICAgIH1cbiAgfVxuXG4gIHN0YXRpYyBnZXREZXJpdmVkU3RhdGVGcm9tRXJyb3IoZXJyb3I6IGFueSkge1xuICAgIGlmIChpc0hUVFBBY2Nlc3NGYWxsYmFja0Vycm9yKGVycm9yKSkge1xuICAgICAgY29uc3QgaHR0cFN0YXR1cyA9IGdldEFjY2Vzc0ZhbGxiYWNrSFRUUFN0YXR1cyhlcnJvcilcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHRyaWdnZXJlZFN0YXR1czogaHR0cFN0YXR1cyxcbiAgICAgIH1cbiAgICB9XG4gICAgLy8gUmUtdGhyb3cgaWYgZXJyb3IgaXMgbm90IGZvciA0MDRcbiAgICB0aHJvdyBlcnJvclxuICB9XG5cbiAgc3RhdGljIGdldERlcml2ZWRTdGF0ZUZyb21Qcm9wcyhcbiAgICBwcm9wczogSFRUUEFjY2Vzc0ZhbGxiYWNrRXJyb3JCb3VuZGFyeVByb3BzLFxuICAgIHN0YXRlOiBIVFRQQWNjZXNzQm91bmRhcnlTdGF0ZVxuICApOiBIVFRQQWNjZXNzQm91bmRhcnlTdGF0ZSB8IG51bGwge1xuICAgIC8qKlxuICAgICAqIEhhbmRsZXMgcmVzZXQgb2YgdGhlIGVycm9yIGJvdW5kYXJ5IHdoZW4gYSBuYXZpZ2F0aW9uIGhhcHBlbnMuXG4gICAgICogRW5zdXJlcyB0aGUgZXJyb3IgYm91bmRhcnkgZG9lcyBub3Qgc3RheSBlbmFibGVkIHdoZW4gbmF2aWdhdGluZyB0byBhIG5ldyBwYWdlLlxuICAgICAqIEFwcHJvYWNoIG9mIHNldFN0YXRlIGluIHJlbmRlciBpcyBzYWZlIGFzIGl0IGNoZWNrcyB0aGUgcHJldmlvdXMgcGF0aG5hbWUgYW5kIHRoZW4gb3ZlcnJpZGVzXG4gICAgICogaXQgYXMgb3V0bGluZWQgaW4gaHR0cHM6Ly9yZWFjdC5kZXYvcmVmZXJlbmNlL3JlYWN0L3VzZVN0YXRlI3N0b3JpbmctaW5mb3JtYXRpb24tZnJvbS1wcmV2aW91cy1yZW5kZXJzXG4gICAgICovXG4gICAgaWYgKHByb3BzLnBhdGhuYW1lICE9PSBzdGF0ZS5wcmV2aW91c1BhdGhuYW1lICYmIHN0YXRlLnRyaWdnZXJlZFN0YXR1cykge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgdHJpZ2dlcmVkU3RhdHVzOiB1bmRlZmluZWQsXG4gICAgICAgIHByZXZpb3VzUGF0aG5hbWU6IHByb3BzLnBhdGhuYW1lLFxuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4ge1xuICAgICAgdHJpZ2dlcmVkU3RhdHVzOiBzdGF0ZS50cmlnZ2VyZWRTdGF0dXMsXG4gICAgICBwcmV2aW91c1BhdGhuYW1lOiBwcm9wcy5wYXRobmFtZSxcbiAgICB9XG4gIH1cblxuICByZW5kZXIoKSB7XG4gICAgY29uc3QgeyBub3RGb3VuZCwgZm9yYmlkZGVuLCB1bmF1dGhvcml6ZWQsIGNoaWxkcmVuIH0gPSB0aGlzLnByb3BzXG4gICAgY29uc3QgeyB0cmlnZ2VyZWRTdGF0dXMgfSA9IHRoaXMuc3RhdGVcbiAgICBjb25zdCBlcnJvckNvbXBvbmVudHMgPSB7XG4gICAgICBbSFRUUEFjY2Vzc0Vycm9yU3RhdHVzLk5PVF9GT1VORF06IG5vdEZvdW5kLFxuICAgICAgW0hUVFBBY2Nlc3NFcnJvclN0YXR1cy5GT1JCSURERU5dOiBmb3JiaWRkZW4sXG4gICAgICBbSFRUUEFjY2Vzc0Vycm9yU3RhdHVzLlVOQVVUSE9SSVpFRF06IHVuYXV0aG9yaXplZCxcbiAgICB9XG5cbiAgICBpZiAodHJpZ2dlcmVkU3RhdHVzKSB7XG4gICAgICBjb25zdCBpc05vdEZvdW5kID1cbiAgICAgICAgdHJpZ2dlcmVkU3RhdHVzID09PSBIVFRQQWNjZXNzRXJyb3JTdGF0dXMuTk9UX0ZPVU5EICYmIG5vdEZvdW5kXG4gICAgICBjb25zdCBpc0ZvcmJpZGRlbiA9XG4gICAgICAgIHRyaWdnZXJlZFN0YXR1cyA9PT0gSFRUUEFjY2Vzc0Vycm9yU3RhdHVzLkZPUkJJRERFTiAmJiBmb3JiaWRkZW5cbiAgICAgIGNvbnN0IGlzVW5hdXRob3JpemVkID1cbiAgICAgICAgdHJpZ2dlcmVkU3RhdHVzID09PSBIVFRQQWNjZXNzRXJyb3JTdGF0dXMuVU5BVVRIT1JJWkVEICYmIHVuYXV0aG9yaXplZFxuXG4gICAgICAvLyBJZiB0aGVyZSdzIG5vIG1hdGNoZWQgYm91bmRhcnkgaW4gdGhpcyBsYXllciwga2VlcCB0aHJvd2luZyB0aGUgZXJyb3IgYnkgcmVuZGVyaW5nIHRoZSBjaGlsZHJlblxuICAgICAgaWYgKCEoaXNOb3RGb3VuZCB8fCBpc0ZvcmJpZGRlbiB8fCBpc1VuYXV0aG9yaXplZCkpIHtcbiAgICAgICAgcmV0dXJuIGNoaWxkcmVuXG4gICAgICB9XG5cbiAgICAgIHJldHVybiAoXG4gICAgICAgIDw+XG4gICAgICAgICAgPG1ldGEgbmFtZT1cInJvYm90c1wiIGNvbnRlbnQ9XCJub2luZGV4XCIgLz5cbiAgICAgICAgICB7cHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09ICdkZXZlbG9wbWVudCcgJiYgKFxuICAgICAgICAgICAgPG1ldGFcbiAgICAgICAgICAgICAgbmFtZT1cImJvdW5kYXJ5LW5leHQtZXJyb3JcIlxuICAgICAgICAgICAgICBjb250ZW50PXtnZXRBY2Nlc3NGYWxsYmFja0Vycm9yVHlwZUJ5U3RhdHVzKHRyaWdnZXJlZFN0YXR1cyl9XG4gICAgICAgICAgICAvPlxuICAgICAgICAgICl9XG4gICAgICAgICAge2Vycm9yQ29tcG9uZW50c1t0cmlnZ2VyZWRTdGF0dXNdfVxuICAgICAgICA8Lz5cbiAgICAgIClcbiAgICB9XG5cbiAgICByZXR1cm4gY2hpbGRyZW5cbiAgfVxufVxuXG5leHBvcnQgZnVuY3Rpb24gSFRUUEFjY2Vzc0ZhbGxiYWNrQm91bmRhcnkoe1xuICBub3RGb3VuZCxcbiAgZm9yYmlkZGVuLFxuICB1bmF1dGhvcml6ZWQsXG4gIGNoaWxkcmVuLFxufTogSFRUUEFjY2Vzc0ZhbGxiYWNrQm91bmRhcnlQcm9wcykge1xuICAvLyBXaGVuIHdlJ3JlIHJlbmRlcmluZyB0aGUgbWlzc2luZyBwYXJhbXMgc2hlbGwsIHRoaXMgd2lsbCByZXR1cm4gbnVsbC4gVGhpc1xuICAvLyBpcyBiZWNhdXNlIHdlIHdvbid0IGJlIHJlbmRlcmluZyBhbnkgbm90IGZvdW5kIGJvdW5kYXJpZXMgb3IgZXJyb3JcbiAgLy8gYm91bmRhcmllcyBmb3IgdGhlIG1pc3NpbmcgcGFyYW1zIHNoZWxsLiBXaGVuIHRoaXMgcnVucyBvbiB0aGUgY2xpZW50XG4gIC8vICh3aGVyZSB0aGVzZSBlcnJvciBjYW4gb2NjdXIpLCB3ZSB3aWxsIGdldCB0aGUgY29ycmVjdCBwYXRobmFtZS5cbiAgY29uc3QgcGF0aG5hbWUgPSB1c2VVbnRyYWNrZWRQYXRobmFtZSgpXG4gIGNvbnN0IG1pc3NpbmdTbG90cyA9IHVzZUNvbnRleHQoTWlzc2luZ1Nsb3RDb250ZXh0KVxuICBjb25zdCBoYXNFcnJvckZhbGxiYWNrID0gISEobm90Rm91bmQgfHwgZm9yYmlkZGVuIHx8IHVuYXV0aG9yaXplZClcblxuICBpZiAoaGFzRXJyb3JGYWxsYmFjaykge1xuICAgIHJldHVybiAoXG4gICAgICA8SFRUUEFjY2Vzc0ZhbGxiYWNrRXJyb3JCb3VuZGFyeVxuICAgICAgICBwYXRobmFtZT17cGF0aG5hbWV9XG4gICAgICAgIG5vdEZvdW5kPXtub3RGb3VuZH1cbiAgICAgICAgZm9yYmlkZGVuPXtmb3JiaWRkZW59XG4gICAgICAgIHVuYXV0aG9yaXplZD17dW5hdXRob3JpemVkfVxuICAgICAgICBtaXNzaW5nU2xvdHM9e21pc3NpbmdTbG90c31cbiAgICAgID5cbiAgICAgICAge2NoaWxkcmVufVxuICAgICAgPC9IVFRQQWNjZXNzRmFsbGJhY2tFcnJvckJvdW5kYXJ5PlxuICAgIClcbiAgfVxuXG4gIHJldHVybiA8PntjaGlsZHJlbn08Lz5cbn1cbiJdLCJuYW1lcyI6WyJIVFRQQWNjZXNzRmFsbGJhY2tCb3VuZGFyeSIsIkhUVFBBY2Nlc3NGYWxsYmFja0Vycm9yQm91bmRhcnkiLCJSZWFjdCIsIkNvbXBvbmVudCIsImNvbXBvbmVudERpZENhdGNoIiwicHJvY2VzcyIsImVudiIsIk5PREVfRU5WIiwicHJvcHMiLCJtaXNzaW5nU2xvdHMiLCJzaXplIiwiaGFzIiwid2FybmluZ01lc3NhZ2UiLCJmb3JtYXR0ZWRTbG90cyIsIkFycmF5IiwiZnJvbSIsInNvcnQiLCJhIiwiYiIsImxvY2FsZUNvbXBhcmUiLCJtYXAiLCJzbG90Iiwiam9pbiIsIndhcm5PbmNlIiwiZ2V0RGVyaXZlZFN0YXRlRnJvbUVycm9yIiwiZXJyb3IiLCJpc0hUVFBBY2Nlc3NGYWxsYmFja0Vycm9yIiwiaHR0cFN0YXR1cyIsImdldEFjY2Vzc0ZhbGxiYWNrSFRUUFN0YXR1cyIsInRyaWdnZXJlZFN0YXR1cyIsImdldERlcml2ZWRTdGF0ZUZyb21Qcm9wcyIsInN0YXRlIiwicGF0aG5hbWUiLCJwcmV2aW91c1BhdGhuYW1lIiwidW5kZWZpbmVkIiwicmVuZGVyIiwibm90Rm91bmQiLCJmb3JiaWRkZW4iLCJ1bmF1dGhvcml6ZWQiLCJjaGlsZHJlbiIsImVycm9yQ29tcG9uZW50cyIsIkhUVFBBY2Nlc3NFcnJvclN0YXR1cyIsIk5PVF9GT1VORCIsIkZPUkJJRERFTiIsIlVOQVVUSE9SSVpFRCIsImlzTm90Rm91bmQiLCJpc0ZvcmJpZGRlbiIsImlzVW5hdXRob3JpemVkIiwibWV0YSIsIm5hbWUiLCJjb250ZW50IiwiZ2V0QWNjZXNzRmFsbGJhY2tFcnJvclR5cGVCeVN0YXR1cyIsImNvbnN0cnVjdG9yIiwidXNlVW50cmFja2VkUGF0aG5hbWUiLCJ1c2VDb250ZXh0IiwiTWlzc2luZ1Nsb3RDb250ZXh0IiwiaGFzRXJyb3JGYWxsYmFjayJdLCJpZ25vcmVMaXN0IjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/next/dist/client/components/http-access-fallback/error-boundary.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/next/dist/client/react-client-callbacks/error-boundary-callbacks.js":
/*!******************************************************************************************!*\
  !*** ./node_modules/next/dist/client/react-client-callbacks/error-boundary-callbacks.js ***!
  \******************************************************************************************/
/***/ ((module, exports, __webpack_require__) => {

eval(__webpack_require__.ts("// This file is only used in app router due to the specific error state handling.\n\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\n0 && (0);\nfunction _export(target, all) {\n    for(var name in all)Object.defineProperty(target, name, {\n        enumerable: true,\n        get: all[name]\n    });\n}\n_export(exports, {\n    onCaughtError: function() {\n        return onCaughtError;\n    },\n    onUncaughtError: function() {\n        return onUncaughtError;\n    }\n});\nconst _stitchederror = __webpack_require__(/*! ../components/errors/stitched-error */ \"(app-pages-browser)/./node_modules/next/dist/client/components/errors/stitched-error.js\");\nconst _useerrorhandler = __webpack_require__(/*! ../components/errors/use-error-handler */ \"(app-pages-browser)/./node_modules/next/dist/client/components/errors/use-error-handler.js\");\nconst _isnextroutererror = __webpack_require__(/*! ../components/is-next-router-error */ \"(app-pages-browser)/./node_modules/next/dist/client/components/is-next-router-error.js\");\nconst _bailouttocsr = __webpack_require__(/*! ../../shared/lib/lazy-dynamic/bailout-to-csr */ \"(app-pages-browser)/./node_modules/next/dist/shared/lib/lazy-dynamic/bailout-to-csr.js\");\nconst _reportglobalerror = __webpack_require__(/*! ./report-global-error */ \"(app-pages-browser)/./node_modules/next/dist/client/react-client-callbacks/report-global-error.js\");\nconst _interceptconsoleerror = __webpack_require__(/*! ../components/globals/intercept-console-error */ \"(app-pages-browser)/./node_modules/next/dist/client/components/globals/intercept-console-error.js\");\nconst _errorboundary = __webpack_require__(/*! ../components/error-boundary */ \"(app-pages-browser)/./node_modules/next/dist/client/components/error-boundary.js\");\nfunction onCaughtError(err, errorInfo) {\n    var _errorInfo_errorBoundary;\n    const errorBoundaryComponent = (_errorInfo_errorBoundary = errorInfo.errorBoundary) == null ? void 0 : _errorInfo_errorBoundary.constructor;\n    let isImplicitErrorBoundary;\n    if (true) {\n        const { AppDevOverlayErrorBoundary } = __webpack_require__(/*! ../components/react-dev-overlay/app/app-dev-overlay-error-boundary */ \"(app-pages-browser)/./node_modules/next/dist/client/components/react-dev-overlay/app/app-dev-overlay-error-boundary.js\");\n        isImplicitErrorBoundary = errorBoundaryComponent === AppDevOverlayErrorBoundary;\n    }\n    isImplicitErrorBoundary = isImplicitErrorBoundary || errorBoundaryComponent === _errorboundary.ErrorBoundaryHandler && errorInfo.errorBoundary.props.errorComponent === _errorboundary.GlobalError;\n    if (isImplicitErrorBoundary) {\n        // We don't consider errors caught unless they're caught by an explicit error\n        // boundary. The built-in ones are considered implicit.\n        // This mimics how the same app would behave without Next.js.\n        return onUncaughtError(err, errorInfo);\n    }\n    // Skip certain custom errors which are not expected to be reported on client\n    if ((0, _bailouttocsr.isBailoutToCSRError)(err) || (0, _isnextroutererror.isNextRouterError)(err)) return;\n    if (true) {\n        var _errorInfo_componentStack;\n        const errorBoundaryName = (errorBoundaryComponent == null ? void 0 : errorBoundaryComponent.displayName) || (errorBoundaryComponent == null ? void 0 : errorBoundaryComponent.name) || 'Unknown';\n        const componentThatErroredFrame = errorInfo == null ? void 0 : (_errorInfo_componentStack = errorInfo.componentStack) == null ? void 0 : _errorInfo_componentStack.split('\\n')[1];\n        var // example 1: at Page (http://localhost:3000/_next/static/chunks/pages/index.js?ts=1631600000000:2:1)\n        // example 2: Page@http://localhost:3000/_next/static/chunks/pages/index.js?ts=1631600000000:2:1\n        _componentThatErroredFrame_match;\n        // Match chrome or safari stack trace\n        const matches = (_componentThatErroredFrame_match = componentThatErroredFrame == null ? void 0 : componentThatErroredFrame.match(/\\s+at (\\w+)\\s+|(\\w+)@/)) != null ? _componentThatErroredFrame_match : [];\n        const componentThatErroredName = matches[1] || matches[2] || 'Unknown';\n        // Create error location with errored component and error boundary, to match the behavior of default React onCaughtError handler.\n        const errorBoundaryMessage = \"It was handled by the <\" + errorBoundaryName + \"> error boundary.\";\n        const componentErrorMessage = componentThatErroredName ? \"The above error occurred in the <\" + componentThatErroredName + \"> component.\" : \"The above error occurred in one of your components.\";\n        const errorLocation = componentErrorMessage + \" \" + errorBoundaryMessage;\n        const stitchedError = (0, _stitchederror.getReactStitchedError)(err);\n        // TODO: change to passing down errorInfo later\n        // In development mode, pass along the component stack to the error\n        if (errorInfo.componentStack) {\n            ;\n            stitchedError._componentStack = errorInfo.componentStack;\n        }\n        // Log and report the error with location but without modifying the error stack\n        (0, _interceptconsoleerror.originConsoleError)('%o\\n\\n%s', err, errorLocation);\n        (0, _useerrorhandler.handleClientError)(stitchedError, []);\n    } else {}\n}\nfunction onUncaughtError(err, errorInfo) {\n    // Skip certain custom errors which are not expected to be reported on client\n    if ((0, _bailouttocsr.isBailoutToCSRError)(err) || (0, _isnextroutererror.isNextRouterError)(err)) return;\n    if (true) {\n        const stitchedError = (0, _stitchederror.getReactStitchedError)(err);\n        // TODO: change to passing down errorInfo later\n        // In development mode, pass along the component stack to the error\n        if (errorInfo.componentStack) {\n            ;\n            stitchedError._componentStack = errorInfo.componentStack;\n        }\n        // TODO: Add an adendum to the overlay telling people about custom error boundaries.\n        (0, _reportglobalerror.reportGlobalError)(stitchedError);\n    } else {}\n}\nif ((typeof exports.default === 'function' || typeof exports.default === 'object' && exports.default !== null) && typeof exports.default.__esModule === 'undefined') {\n    Object.defineProperty(exports.default, '__esModule', {\n        value: true\n    });\n    Object.assign(exports.default, exports);\n    module.exports = exports.default;\n} //# sourceMappingURL=error-boundary-callbacks.js.map\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvY2xpZW50L3JlYWN0LWNsaWVudC1jYWxsYmFja3MvZXJyb3ItYm91bmRhcnktY2FsbGJhY2tzLmpzIiwibWFwcGluZ3MiOiJBQUFBLGlGQUFpRjs7Ozs7Ozs7Ozs7OztJQWNqRUEsYUFBYTtlQUFiQTs7SUF5RUFDLGVBQWU7ZUFBZkE7OzsyQ0FwRnNCOzZDQUNKOytDQUNBOzBDQUNFOytDQUNGO21EQUNDOzJDQUk1QjtBQUVBLFNBQVNELGNBQ2RFLEdBQVksRUFDWkMsU0FBMEQ7UUFFM0JBO0lBQS9CLE1BQU1DLHlCQUFBQSxDQUF5QkQsMkJBQUFBLFVBQVVFLGFBQWEscUJBQXZCRix5QkFBeUJHLFdBQVc7SUFFbkUsSUFBSUM7SUFFSixJQUFJQyxJQUFvQixFQUFtQjtRQUN6QyxNQUFNLEVBQUVHLDBCQUEwQixFQUFFLEdBQ2xDQyxtQkFBT0EsQ0FBQyxrTUFBb0U7UUFFOUVMLDBCQUNFSCwyQkFBMkJPO0lBQy9CO0lBRUFKLDBCQUNFQSwyQkFDQ0gsMkJBQTJCUyxlQUFBQSxvQkFBb0IsSUFDN0NWLFVBQVVFLGFBQWEsQ0FDckJTLEtBQUssQ0FBQ0MsY0FBYyxLQUFLQyxlQUFBQSxXQUFvQjtJQUVwRCxJQUFJVCx5QkFBeUI7UUFDM0IsNkVBQTZFO1FBQzdFLHVEQUF1RDtRQUN2RCw2REFBNkQ7UUFDN0QsT0FBT04sZ0JBQWdCQyxLQUFLQztJQUM5QjtJQUVBLDZFQUE2RTtJQUM3RSxJQUFJYyxDQUFBQSxHQUFBQSxjQUFBQSxtQkFBQUEsRUFBb0JmLFFBQVFnQixDQUFBQSxHQUFBQSxtQkFBQUEsaUJBQUFBLEVBQWtCaEIsTUFBTTtJQUV4RCxJQUFJTSxJQUFvQixFQUFtQjtZQU9QTDtRQU5sQyxNQUFNZ0Isb0JBRUosQ0FEQSwwQkFDQ2YsT0FBQUEsRUFEa0MsR0FDbENBLElBQUFBLHVCQUFnQ2dCLFdBQUFBLE1BQ2pDaEIsMEJBQUFBLE9BQUFBLEtBQUFBLElBQUFBLHVCQUF3QmlCLElBQUFBLEtBQ3hCO1FBRUYsTUFBTUMsNEJBQTRCbkIsYUFBQUEsT0FBQUEsS0FBQUEsSUFBQUEsQ0FBQUEsNEJBQUFBLFVBQVdvQixjQUFBQSxLQUFjLGdCQUF6QnBCLDBCQUEyQnFCLEtBQUssQ0FBQyxLQUFLLENBQUMsRUFBRTtZQUl6RSxzREFBc0QsK0NBQytDO1FBQ3JHLGdHQUFnRztRQUNoR0Y7UUFMRixxQ0FBcUM7UUFDckMsTUFBTUcsVUFJSkgsQ0FBQUEsbUNBQUFBLDZCQUFBQSxPQUFBQSxLQUFBQSxJQUFBQSwwQkFBMkJJLEtBQUssQ0FBQyxvQ0FBakNKLG1DQUE2RCxFQUFFO1FBQ2pFLE1BQU1LLDJCQUEyQkYsT0FBTyxDQUFDLEVBQUUsSUFBSUEsT0FBTyxDQUFDLEVBQUUsSUFBSTtRQUU3RCxpSUFBaUk7UUFDakksTUFBTUcsdUJBQXdCLDRCQUF5QlQsb0JBQWtCO1FBQ3pFLE1BQU1VLHdCQUF3QkYsMkJBQ3pCLHNDQUFtQ0EsMkJBQXlCLGlCQUM1RDtRQUVMLE1BQU1HLGdCQUFtQkQsd0JBQXNCLE1BQUdEO1FBRWxELE1BQU1HLGdCQUFnQkMsQ0FBQUEsR0FBQUEsZUFBQUEscUJBQUFBLEVBQXNCOUI7UUFDNUMsK0NBQStDO1FBQy9DLG1FQUFtRTtRQUNuRSxJQUFJQyxVQUFVb0IsY0FBYyxFQUFFOztZQUMxQlEsY0FBc0JFLGVBQWUsR0FBRzlCLFVBQVVvQixjQUFjO1FBQ3BFO1FBRUEsK0VBQStFO1FBQy9FVyxDQUFBQSxHQUFBQSx1QkFBQUEsa0JBQUFBLEVBQW1CLFlBQVloQyxLQUFLNEI7UUFFcENLLENBQUFBLEdBQUFBLGlCQUFBQSxpQkFBaUIsRUFBQ0osZUFBZSxFQUFFO0lBQ3JDLE9BQU8sRUFFTjtBQUNIO0FBRU8sU0FBUzlCLGdCQUFnQkMsR0FBWSxFQUFFQyxTQUEwQjtJQUN0RSw2RUFBNkU7SUFDN0UsSUFBSWMsQ0FBQUEsR0FBQUEsY0FBQUEsbUJBQUFBLEVBQW9CZixRQUFRZ0IsQ0FBQUEsR0FBQUEsbUJBQUFBLGlCQUFBQSxFQUFrQmhCLE1BQU07SUFFeEQsSUFBSU0sSUFBb0IsRUFBbUI7UUFDekMsTUFBTXVCLGdCQUFnQkMsQ0FBQUEsR0FBQUEsZUFBQUEscUJBQUFBLEVBQXNCOUI7UUFDNUMsK0NBQStDO1FBQy9DLG1FQUFtRTtRQUNuRSxJQUFJQyxVQUFVb0IsY0FBYyxFQUFFOztZQUMxQlEsY0FBc0JFLGVBQWUsR0FBRzlCLFVBQVVvQixjQUFjO1FBQ3BFO1FBRUEsb0ZBQW9GO1FBQ3BGYSxDQUFBQSxHQUFBQSxtQkFBQUEsaUJBQUFBLEVBQWtCTDtJQUNwQixPQUFPLEVBRU47QUFDSCIsInNvdXJjZXMiOlsiL1VzZXJzL3NyYy9jbGllbnQvcmVhY3QtY2xpZW50LWNhbGxiYWNrcy9lcnJvci1ib3VuZGFyeS1jYWxsYmFja3MudHMiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gVGhpcyBmaWxlIGlzIG9ubHkgdXNlZCBpbiBhcHAgcm91dGVyIGR1ZSB0byB0aGUgc3BlY2lmaWMgZXJyb3Igc3RhdGUgaGFuZGxpbmcuXG5cbmltcG9ydCB0eXBlIHsgRXJyb3JJbmZvIH0gZnJvbSAncmVhY3QnXG5pbXBvcnQgeyBnZXRSZWFjdFN0aXRjaGVkRXJyb3IgfSBmcm9tICcuLi9jb21wb25lbnRzL2Vycm9ycy9zdGl0Y2hlZC1lcnJvcidcbmltcG9ydCB7IGhhbmRsZUNsaWVudEVycm9yIH0gZnJvbSAnLi4vY29tcG9uZW50cy9lcnJvcnMvdXNlLWVycm9yLWhhbmRsZXInXG5pbXBvcnQgeyBpc05leHRSb3V0ZXJFcnJvciB9IGZyb20gJy4uL2NvbXBvbmVudHMvaXMtbmV4dC1yb3V0ZXItZXJyb3InXG5pbXBvcnQgeyBpc0JhaWxvdXRUb0NTUkVycm9yIH0gZnJvbSAnLi4vLi4vc2hhcmVkL2xpYi9sYXp5LWR5bmFtaWMvYmFpbG91dC10by1jc3InXG5pbXBvcnQgeyByZXBvcnRHbG9iYWxFcnJvciB9IGZyb20gJy4vcmVwb3J0LWdsb2JhbC1lcnJvcidcbmltcG9ydCB7IG9yaWdpbkNvbnNvbGVFcnJvciB9IGZyb20gJy4uL2NvbXBvbmVudHMvZ2xvYmFscy9pbnRlcmNlcHQtY29uc29sZS1lcnJvcidcbmltcG9ydCB7XG4gIEVycm9yQm91bmRhcnlIYW5kbGVyLFxuICBHbG9iYWxFcnJvciBhcyBEZWZhdWx0RXJyb3JCb3VuZGFyeSxcbn0gZnJvbSAnLi4vY29tcG9uZW50cy9lcnJvci1ib3VuZGFyeSdcblxuZXhwb3J0IGZ1bmN0aW9uIG9uQ2F1Z2h0RXJyb3IoXG4gIGVycjogdW5rbm93bixcbiAgZXJyb3JJbmZvOiBFcnJvckluZm8gJiB7IGVycm9yQm91bmRhcnk/OiBSZWFjdC5Db21wb25lbnQgfVxuKSB7XG4gIGNvbnN0IGVycm9yQm91bmRhcnlDb21wb25lbnQgPSBlcnJvckluZm8uZXJyb3JCb3VuZGFyeT8uY29uc3RydWN0b3JcblxuICBsZXQgaXNJbXBsaWNpdEVycm9yQm91bmRhcnlcblxuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgIGNvbnN0IHsgQXBwRGV2T3ZlcmxheUVycm9yQm91bmRhcnkgfSA9XG4gICAgICByZXF1aXJlKCcuLi9jb21wb25lbnRzL3JlYWN0LWRldi1vdmVybGF5L2FwcC9hcHAtZGV2LW92ZXJsYXktZXJyb3ItYm91bmRhcnknKSBhcyB0eXBlb2YgaW1wb3J0KCcuLi9jb21wb25lbnRzL3JlYWN0LWRldi1vdmVybGF5L2FwcC9hcHAtZGV2LW92ZXJsYXktZXJyb3ItYm91bmRhcnknKVxuXG4gICAgaXNJbXBsaWNpdEVycm9yQm91bmRhcnkgPVxuICAgICAgZXJyb3JCb3VuZGFyeUNvbXBvbmVudCA9PT0gQXBwRGV2T3ZlcmxheUVycm9yQm91bmRhcnlcbiAgfVxuXG4gIGlzSW1wbGljaXRFcnJvckJvdW5kYXJ5ID1cbiAgICBpc0ltcGxpY2l0RXJyb3JCb3VuZGFyeSB8fFxuICAgIChlcnJvckJvdW5kYXJ5Q29tcG9uZW50ID09PSBFcnJvckJvdW5kYXJ5SGFuZGxlciAmJlxuICAgICAgKGVycm9ySW5mby5lcnJvckJvdW5kYXJ5ISBhcyBJbnN0YW5jZVR5cGU8dHlwZW9mIEVycm9yQm91bmRhcnlIYW5kbGVyPilcbiAgICAgICAgLnByb3BzLmVycm9yQ29tcG9uZW50ID09PSBEZWZhdWx0RXJyb3JCb3VuZGFyeSlcblxuICBpZiAoaXNJbXBsaWNpdEVycm9yQm91bmRhcnkpIHtcbiAgICAvLyBXZSBkb24ndCBjb25zaWRlciBlcnJvcnMgY2F1Z2h0IHVubGVzcyB0aGV5J3JlIGNhdWdodCBieSBhbiBleHBsaWNpdCBlcnJvclxuICAgIC8vIGJvdW5kYXJ5LiBUaGUgYnVpbHQtaW4gb25lcyBhcmUgY29uc2lkZXJlZCBpbXBsaWNpdC5cbiAgICAvLyBUaGlzIG1pbWljcyBob3cgdGhlIHNhbWUgYXBwIHdvdWxkIGJlaGF2ZSB3aXRob3V0IE5leHQuanMuXG4gICAgcmV0dXJuIG9uVW5jYXVnaHRFcnJvcihlcnIsIGVycm9ySW5mbylcbiAgfVxuXG4gIC8vIFNraXAgY2VydGFpbiBjdXN0b20gZXJyb3JzIHdoaWNoIGFyZSBub3QgZXhwZWN0ZWQgdG8gYmUgcmVwb3J0ZWQgb24gY2xpZW50XG4gIGlmIChpc0JhaWxvdXRUb0NTUkVycm9yKGVycikgfHwgaXNOZXh0Um91dGVyRXJyb3IoZXJyKSkgcmV0dXJuXG5cbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICBjb25zdCBlcnJvckJvdW5kYXJ5TmFtZSA9XG4gICAgICAvLyByZWFkIHJlYWN0IGNvbXBvbmVudCBkaXNwbGF5TmFtZVxuICAgICAgKGVycm9yQm91bmRhcnlDb21wb25lbnQgYXMgYW55KT8uZGlzcGxheU5hbWUgfHxcbiAgICAgIGVycm9yQm91bmRhcnlDb21wb25lbnQ/Lm5hbWUgfHxcbiAgICAgICdVbmtub3duJ1xuXG4gICAgY29uc3QgY29tcG9uZW50VGhhdEVycm9yZWRGcmFtZSA9IGVycm9ySW5mbz8uY29tcG9uZW50U3RhY2s/LnNwbGl0KCdcXG4nKVsxXVxuXG4gICAgLy8gTWF0Y2ggY2hyb21lIG9yIHNhZmFyaSBzdGFjayB0cmFjZVxuICAgIGNvbnN0IG1hdGNoZXMgPVxuICAgICAgLy8gcmVnZXggdG8gbWF0Y2ggdGhlIGZ1bmN0aW9uIG5hbWUgaW4gdGhlIHN0YWNrIHRyYWNlXG4gICAgICAvLyBleGFtcGxlIDE6IGF0IFBhZ2UgKGh0dHA6Ly9sb2NhbGhvc3Q6MzAwMC9fbmV4dC9zdGF0aWMvY2h1bmtzL3BhZ2VzL2luZGV4LmpzP3RzPTE2MzE2MDAwMDAwMDA6MjoxKVxuICAgICAgLy8gZXhhbXBsZSAyOiBQYWdlQGh0dHA6Ly9sb2NhbGhvc3Q6MzAwMC9fbmV4dC9zdGF0aWMvY2h1bmtzL3BhZ2VzL2luZGV4LmpzP3RzPTE2MzE2MDAwMDAwMDA6MjoxXG4gICAgICBjb21wb25lbnRUaGF0RXJyb3JlZEZyYW1lPy5tYXRjaCgvXFxzK2F0IChcXHcrKVxccyt8KFxcdyspQC8pID8/IFtdXG4gICAgY29uc3QgY29tcG9uZW50VGhhdEVycm9yZWROYW1lID0gbWF0Y2hlc1sxXSB8fCBtYXRjaGVzWzJdIHx8ICdVbmtub3duJ1xuXG4gICAgLy8gQ3JlYXRlIGVycm9yIGxvY2F0aW9uIHdpdGggZXJyb3JlZCBjb21wb25lbnQgYW5kIGVycm9yIGJvdW5kYXJ5LCB0byBtYXRjaCB0aGUgYmVoYXZpb3Igb2YgZGVmYXVsdCBSZWFjdCBvbkNhdWdodEVycm9yIGhhbmRsZXIuXG4gICAgY29uc3QgZXJyb3JCb3VuZGFyeU1lc3NhZ2UgPSBgSXQgd2FzIGhhbmRsZWQgYnkgdGhlIDwke2Vycm9yQm91bmRhcnlOYW1lfT4gZXJyb3IgYm91bmRhcnkuYFxuICAgIGNvbnN0IGNvbXBvbmVudEVycm9yTWVzc2FnZSA9IGNvbXBvbmVudFRoYXRFcnJvcmVkTmFtZVxuICAgICAgPyBgVGhlIGFib3ZlIGVycm9yIG9jY3VycmVkIGluIHRoZSA8JHtjb21wb25lbnRUaGF0RXJyb3JlZE5hbWV9PiBjb21wb25lbnQuYFxuICAgICAgOiBgVGhlIGFib3ZlIGVycm9yIG9jY3VycmVkIGluIG9uZSBvZiB5b3VyIGNvbXBvbmVudHMuYFxuXG4gICAgY29uc3QgZXJyb3JMb2NhdGlvbiA9IGAke2NvbXBvbmVudEVycm9yTWVzc2FnZX0gJHtlcnJvckJvdW5kYXJ5TWVzc2FnZX1gXG5cbiAgICBjb25zdCBzdGl0Y2hlZEVycm9yID0gZ2V0UmVhY3RTdGl0Y2hlZEVycm9yKGVycilcbiAgICAvLyBUT0RPOiBjaGFuZ2UgdG8gcGFzc2luZyBkb3duIGVycm9ySW5mbyBsYXRlclxuICAgIC8vIEluIGRldmVsb3BtZW50IG1vZGUsIHBhc3MgYWxvbmcgdGhlIGNvbXBvbmVudCBzdGFjayB0byB0aGUgZXJyb3JcbiAgICBpZiAoZXJyb3JJbmZvLmNvbXBvbmVudFN0YWNrKSB7XG4gICAgICA7KHN0aXRjaGVkRXJyb3IgYXMgYW55KS5fY29tcG9uZW50U3RhY2sgPSBlcnJvckluZm8uY29tcG9uZW50U3RhY2tcbiAgICB9XG5cbiAgICAvLyBMb2cgYW5kIHJlcG9ydCB0aGUgZXJyb3Igd2l0aCBsb2NhdGlvbiBidXQgd2l0aG91dCBtb2RpZnlpbmcgdGhlIGVycm9yIHN0YWNrXG4gICAgb3JpZ2luQ29uc29sZUVycm9yKCclb1xcblxcbiVzJywgZXJyLCBlcnJvckxvY2F0aW9uKVxuXG4gICAgaGFuZGxlQ2xpZW50RXJyb3Ioc3RpdGNoZWRFcnJvciwgW10pXG4gIH0gZWxzZSB7XG4gICAgb3JpZ2luQ29uc29sZUVycm9yKGVycilcbiAgfVxufVxuXG5leHBvcnQgZnVuY3Rpb24gb25VbmNhdWdodEVycm9yKGVycjogdW5rbm93biwgZXJyb3JJbmZvOiBSZWFjdC5FcnJvckluZm8pIHtcbiAgLy8gU2tpcCBjZXJ0YWluIGN1c3RvbSBlcnJvcnMgd2hpY2ggYXJlIG5vdCBleHBlY3RlZCB0byBiZSByZXBvcnRlZCBvbiBjbGllbnRcbiAgaWYgKGlzQmFpbG91dFRvQ1NSRXJyb3IoZXJyKSB8fCBpc05leHRSb3V0ZXJFcnJvcihlcnIpKSByZXR1cm5cblxuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgIGNvbnN0IHN0aXRjaGVkRXJyb3IgPSBnZXRSZWFjdFN0aXRjaGVkRXJyb3IoZXJyKVxuICAgIC8vIFRPRE86IGNoYW5nZSB0byBwYXNzaW5nIGRvd24gZXJyb3JJbmZvIGxhdGVyXG4gICAgLy8gSW4gZGV2ZWxvcG1lbnQgbW9kZSwgcGFzcyBhbG9uZyB0aGUgY29tcG9uZW50IHN0YWNrIHRvIHRoZSBlcnJvclxuICAgIGlmIChlcnJvckluZm8uY29tcG9uZW50U3RhY2spIHtcbiAgICAgIDsoc3RpdGNoZWRFcnJvciBhcyBhbnkpLl9jb21wb25lbnRTdGFjayA9IGVycm9ySW5mby5jb21wb25lbnRTdGFja1xuICAgIH1cblxuICAgIC8vIFRPRE86IEFkZCBhbiBhZGVuZHVtIHRvIHRoZSBvdmVybGF5IHRlbGxpbmcgcGVvcGxlIGFib3V0IGN1c3RvbSBlcnJvciBib3VuZGFyaWVzLlxuICAgIHJlcG9ydEdsb2JhbEVycm9yKHN0aXRjaGVkRXJyb3IpXG4gIH0gZWxzZSB7XG4gICAgcmVwb3J0R2xvYmFsRXJyb3IoZXJyKVxuICB9XG59XG4iXSwibmFtZXMiOlsib25DYXVnaHRFcnJvciIsIm9uVW5jYXVnaHRFcnJvciIsImVyciIsImVycm9ySW5mbyIsImVycm9yQm91bmRhcnlDb21wb25lbnQiLCJlcnJvckJvdW5kYXJ5IiwiY29uc3RydWN0b3IiLCJpc0ltcGxpY2l0RXJyb3JCb3VuZGFyeSIsInByb2Nlc3MiLCJlbnYiLCJOT0RFX0VOViIsIkFwcERldk92ZXJsYXlFcnJvckJvdW5kYXJ5IiwicmVxdWlyZSIsIkVycm9yQm91bmRhcnlIYW5kbGVyIiwicHJvcHMiLCJlcnJvckNvbXBvbmVudCIsIkRlZmF1bHRFcnJvckJvdW5kYXJ5IiwiaXNCYWlsb3V0VG9DU1JFcnJvciIsImlzTmV4dFJvdXRlckVycm9yIiwiZXJyb3JCb3VuZGFyeU5hbWUiLCJkaXNwbGF5TmFtZSIsIm5hbWUiLCJjb21wb25lbnRUaGF0RXJyb3JlZEZyYW1lIiwiY29tcG9uZW50U3RhY2siLCJzcGxpdCIsIm1hdGNoZXMiLCJtYXRjaCIsImNvbXBvbmVudFRoYXRFcnJvcmVkTmFtZSIsImVycm9yQm91bmRhcnlNZXNzYWdlIiwiY29tcG9uZW50RXJyb3JNZXNzYWdlIiwiZXJyb3JMb2NhdGlvbiIsInN0aXRjaGVkRXJyb3IiLCJnZXRSZWFjdFN0aXRjaGVkRXJyb3IiLCJfY29tcG9uZW50U3RhY2siLCJvcmlnaW5Db25zb2xlRXJyb3IiLCJoYW5kbGVDbGllbnRFcnJvciIsInJlcG9ydEdsb2JhbEVycm9yIl0sImlnbm9yZUxpc3QiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/next/dist/client/react-client-callbacks/error-boundary-callbacks.js\n"));

/***/ })

});